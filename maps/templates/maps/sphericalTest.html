{% extends "base.html" %}
{% block title %}{{ block.super }} :: map{% endblock %}

{% block js %}
{{ block.super }}
{% load static %}
<title>Spherical Force-Directed Layout</title>
<script src="http://d3js.org/d3.v4.min.js"></script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script type="text/javascript" src="{% get_static_prefix %}js/jquery-1.10.2.min.js"></script>
<script type="text/javascript" src="{% get_static_prefix %}js/jquery-ui-1.10.3.custom.min.js"></script>

<script src="{% get_static_prefix %}openlayers/OpenLayers-min.js"></script>
<script src="{% get_static_prefix %}openlayers/InlineXhtml/lib/OpenLayers/Tile/InlineXhtml.js"></script>
<script src="{% get_static_prefix %}openlayers/InlineXhtml/lib/OpenLayers/Layer/ScalableInlineXhtml.js"></script>

<style type="text/css">
    body {
        padding: 0;
        margin: 0;
    }

    .graticule {
        fill: none;
        stroke: #777;
        stroke-width: .5px;
        stroke-opacity: 1;
    }

    path.link {
        stroke: #999;
        fill-opacity: 0
    }
</style>

<script type="text/javascript">

    var config, width, height, node, link, borders, fills, projection, projectionEquidistant, path, svgGraticule, svg, jsongraph, chunk, MAXWIDTH = 16;

    $(document).ready(function () {
        width = window.innerWidth;
        height = window.innerHeight;

        svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

        var graticule = d3.geoGraticule();

        projection = d3.geoOrthographic()
            .scale(height / $("#scale").val())
            .translate([(width / 2), height / 2])
            .clipAngle(90);

        $("#scale").on("input", function () {
            chunk = height / $("#scale").attr("max");
            projection.scale(height - chunk * $("#scale").val());

            svg.selectAll("path.graticule")
                .attr("d", path);

            updateGraph(jsongraph);
            updateLabels();
        });

        path = d3.geoPath()
            .projection(projection);

        svgGraticule = svg.append("path")
            .datum(graticule)
            .attr("class", "graticule")
            .attr("d", path);

        svg.call(d3.drag()
            .subject(function () { var r = projection.rotate(); svgGraticule.attr("d", path); return { x: 2 * r[0], y: -2 * r[1] }; })
            .on("drag", function () { svgGraticule.attr("d", path); var r = [d3.event.x / 2, -d3.event.y / 2, projection.rotate()[2]]; t0 = Date.now(); origin = r; projection.rotate(r); updateGraph(jsongraph); updateLabels(); }));

        get_mds();
    });

    function get_mds() {
        $.ajax({
            dataType: "json",
            type: "POST",
            url: "{% url 'maps:get_mds'%}",
            async: true,
            cache: false,
            timeout: 300000,
            success: function (coords) {
                drawGraph(coords);
            },
            // handle error
            error: function (XMLHttpRequest, textStatus, errorThrown) {
            },
        });
    }

    /*document.getElementById("scale").oninput = function () {
        projectionEquidistant.scale(height / (document.getElementById("scale").value));
        force.restart();
    }*/


    async function drawGraph(graph) {
        console.log(graph);

        node = svg.selectAll("path.node")
            .data(graph[0])
            .enter().append("path").attr("class", "node")
            .style("stroke-width", function (d) { return Math.min(5 - $("#scale").val(), MAXWIDTH); })
            .attr("d", function (d) { var p = path({ "type": "Feature", "geometry": { "type": "Point", "coordinates": [d[0], d[1]] } }); return p ? p : 'M 0 0' })
            .attr("x", function (d) { return projection([d[0], d[1]])[0]; })
            .attr("y", function (d) { return projection([d[0], d[1]])[1]; })
            .attr("x1", function (d) { return d[0] })
            .attr("y1", function (d) { return d[1] });
        updateLabels();
        
        await sleep(5000)

        for (var i = 1; i < graph.length; i++){
            await sleep(500);
            drawGraphPiece(graph[i]);
        }
        await sleep(5000);
        drawGraph(graph);
    }

    async function drawGraphPiece(graph) {
        d3.selectAll("path.node").remove();
        node = svg.selectAll("path.node")
            .data(graph)
            .enter().append("path").attr("class", "node")
            .style("stroke-width", function (d) { return Math.min(5 - $("#scale").val(), MAXWIDTH); })
            .attr("d", function (d) { var p = path({ "type": "Feature", "geometry": { "type": "Point", "coordinates": [d[0], d[1]] } }); return p ? p : 'M 0 0' })
            .attr("x", function (d) { return projection([d[0], d[1]])[0]; })
            .attr("y", function (d) { return projection([d[0], d[1]])[1]; })
            .attr("x1", function (d) { return d[0] })
            .attr("y1", function (d) { return d[1] });
        updateLabels();
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function updateGraph(graph) {
        console.log(graph);
        node.each(function (d) {
            d3.select(this)
                .style("stroke-width", function (d) { return Math.min(5 - $("#scale").val(), MAXWIDTH); })
                .attr("d", function (d) { var p = path({ "type": "Feature", "geometry": { "type": "Point", "coordinates": [d[0], d[1]]} }); return p ? p : 'M 0 0' })
                .attr("x", function (d) { return projection([d[0], d[1]])[0]; })
                .attr("y", function (d) { return projection([d[0], d[1]])[1]; })
                .attr("x1", function (d) { return d[0] })
                .attr("y1", function (d) { return d[1] });
        });
        updateLabels();
    }

    function updateLabels() {
        var count = 0;
        d3.selectAll("text").remove();
        node.each(function (d) {
            var temp = d3.select(this);

            var distance = d3.geoDistance(
                [temp.attr("x1"), temp.attr("y1")],
                projection.invert([width / 2, height / 2]));

            if (distance < 1.57079632679490) {
                svg
                    .append("svg:text")
                    .text(function (e) {
                        return count;
                    })
                    .attr("x", function (e) {
                        return temp.attr("x");
                    })
                    .attr("y", function (e) {
                        return temp.attr("y") - 10;
                    })
                    .attr("text-anchor", "middle")
                    .attr('fill', 'black');
            }
            count++;
        })
    }

</script>
{% endblock %}
{% block content %}
<input type="range" min="-100" max="100" value="2" class="slider" id="scale">
{% endblock %}